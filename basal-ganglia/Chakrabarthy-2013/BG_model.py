#!/usr/bin/env python# -----------------------------------------------------------------------------# Copyright (c) 2014, Nicolas P. Rougier# Distributed under the (new) BSD License.## Contributors: Nicolas P. Rougier (Nicolas.Rougier@inria.fr)#               Meropi Topalidou (Meropi.Topalidou@inria.fr)# -----------------------------------------------------------------------------from dana import *import matplotlib.pyplot as plt# Parameters# -----------------------------------------------------------------------------# Population sizen = 20pi = np.pi# Default trial durationduration = 100.0*millisecond# Default Time resolutiondt = 1.0*millisecond# Initialization of the random generator (reproductibility !)np.random.seed(1)#Domanine leveldelta = -0.2#WeightsW = np.ones((1,n))#Helpful functionsdef H(x):    return 1 if x > 0 else 0r = np.zeros((n,n,n,n))for i in range(0,n):    for j in range(0,n):        for p in range(0,n):            for q in range(0,n):                r[i,j,p,q] = np.sqrt((i-p)**2 + (j-q)**2)                      d = np.zeros((n,n))for i in range(0,n):    for p in range(0,n):        d[i,p] = np.abs(i-p)theta_D1 =0.1lamda_D1 = 5*(1/1+np.exp(-6*(delta - theta_D1)))Striatum_D1 = zeros((n,1), """du/dt = -u + V + I_ext;                                                   V = np.tanh(lamda_D1* u); ;  I_ext""")                                            ###;   Striatum_D2 = zeros((n,1), """du/dt = -u + V + I_ext;          V = np.tanh(lamda_D2* u);  lamda_D2 = 5*(1/1+np.exp(-6*(theta_D2 - delta))); theta_D2 = 0.1; I_ext""") theta_GPe = 0.1tau_GPe = 10lamda_GPe = 4 * H(theta_GPe - delta) + 1;  W_GPe = np.ones((1,n))GPe = zeros((n,n), """dx/dt = (-x +  W_lat * np.ones(U.shape) * np.sum(U) +  I_STN * w_sg + I_Str) / tau_GPe;                                   U = np.tanh(lamda_GPe * x);  I_Str = W_GPe * V_D2;                                W_lat = 1; w_sg = 1; V_D2; I_STN""")                                #W_lat# ##       #                                  #W_lat = sigma_STN * np.exp(-r^2/sigma_lat^2 ) if r < R else -1 if r =0 else 0; r; R; sigma_STN = 1; sigma_lat = 0.2;                                 theta_STN = 0.1lamda_STN = 4 * H(theta_STN - delta) + 1tau_STN = 10STN = zeros((n,n), """dx/dt = (-x +  W_lat * np.ones(U.shape) * np.sum(U) +  I_GPe * w_sg + I_Str) / tau_STN;                                   U = np.tanh(lamda_STN * x);  I_Str = W_GPe * V_D2;                                W_lat = 1; w_sg = 1; V_D2; I_GPe""")                                                                                              #((n,1), """dx/dt = (-x +W_lat * U - w_gs * I_GPe) / tau_STN;                                U = np.tanh(lamda_STN * x); W_lat = 1; w_gs = 1; ; I_GPe;; """)                                #W_lat = sigma_GPe * np.exp(-r^2/sigma_lat^2 ) if r < R else -1 if r =0 else 0;                                 #R; sigma_GPe = 1; sigma_lat = 0.2;k_x = 2*pi/n                                tau = 10A = 10 sigma =1.2; C = 0.2; tau =10;W_GPi = A * np.exp(-d**2/(2*sigma**2)) - C;W_STN_GPi = np.ones((1,n))*1./nGPi = zeros((n,1), """du/dt = (-u + np.dot(W_GPi, S) * k_x + I) / tau;                                  S = u**2 / (1 + 1/2 * k_x * np.sum(u**2));                                 I = V_D1  +  np.dot(W_STN_GPi, U_STN); U_STN ; V_D1   """)                                #parameters A, sigma, Ce{0.1,0.3}, k_x, tau are from the article from Standage                                                                     #S;                                              #                                     #                                #I                                #ConnectivityDenseConnection( Striatum_D2('V'), GPe('V_D2'), 1.0 )DenseConnection( STN('U'), GPe('I_STN'), 1.0 )DenseConnection( GPe('U'), STN('I_GPe'), 1.0 )DenseConnection( Striatum_D1('V'), GPi('V_D1'), 1.0 )DenseConnection( STN('U'), GPi('U_STN'), 1.0 )#Stimulus@clock.at(1*millisecond)def stimulus(time):    sigma = 0.4 #sigmaE{0.3,0.5}    d = np.linspace(0,n-1,n).reshape((n,1))    I = np.zeros((n,1))    I[3:7] = 8    I[12:16] = 2    #plt.plot(I)    Striatum_D1['I_ext'] = I    Striatum_D2['I_ext'] = I    # Simulation# -----------------------------------------------------------------------------run(time=duration, dt=dt)#Choiceplt.plot(GPi("S"))choice = 1 if np.sum(GPi("S")[0:10]) > np.sum(GPi("S")[10:20]) else 2print choiceplt.show()